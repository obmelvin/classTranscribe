[{"text":"alright, so, the first surpise is that we see 'I am process' twice","width":960},{"text":"that's weird, why did that happen? let's talk about in a moment","width":192},{"text":"and then second thing is one of the processes ","width":256},{"text":"and my parent is 1","width":192},{"text":"how, why? well remember we made the child sleep. we made it sleep for an extra second. in that second it's original parent finished","width":768},{"text":"it exited. so now what are we going to do with the child now? who's parent should it be?","width":192},{"text":"and now's where the system says 'I know what! we will reparent you back to the ultimate process' parent process id one","width":704},{"text":"so that's what happened there. if we didn't have this sleep then we have a race condition. maybe the parent finished first, maybe the child would've finished first","width":512},{"text":"we cannot say for sure who would finish first so that's why we put the sleep in","width":320},{"text":"but why is it that we saw 'I am process' twice?","width":256},{"text":"OK, if you think you have the answer wave your hand in the air like you just don't care. you care","width":384},{"text":"very good yes. so, a few people know. i'll give you a hint","width":512},{"text":"I'm going to change the program very slightly by putting '\\n' in there","width":832},{"text":"and now you only get 'I am process' once. so by putting ","width":576},{"text":"'\\n' in there I changed the output of the program quite significantly. what does '\\n' do?","width":640},{"text":"yeah! thanks. in our little example here C decides to flush the buffers. so there's abuffer inside the process and it's just collecting bytes. just collecting the characters to print out","width":896},{"text":"but it didn't bother to actually write them out to the system yet. it only decided to do that when we saw the new lines. so in this example we ended up callling write(), we printed it out, before we called fork()","width":1024},{"text":"in the first example it was still inside the process so when we forked it was still there inside the child as well. the child says 'oh yeah,I've still got these bytes to print out. I haven't got round to it yet'","width":768},{"text":"so be wary of this. the other thing to note is that at the very end of the program part of the clean up that the C library does is says 'hey ok any open file descriptors if you have something to write out do it now because this process is closing. it's time to flush all the buffers' so it does that as part of the standard clean up process","width":1728},{"text":"right, so that's a little example there. how much buffering actually happens depends partly on wheter your trying to send it to a terminal or a file","width":704},{"text":"if you're sending stuff to a file it will actually keep buffering beyond the '\\n' so it tries to have even better performance by buffering stuff out to a larger amount before writing them","width":1024},{"text":"questions about this example?","width":192},{"text":"yes?","width":64},{"text":"right, so if we choosed fprintf() ","width":640},{"text":"aha, OK, right, so puts() is equivalent to printf() %s \\n. OK so that would've actually flushed it as well","width":1152},{"text":"and so if I used fprintf() the same thing would've happened if I sent it to standard out because the buffer of standard out by default when I'm sending it to the terminal is to wait until I say new line","width":832},{"text":"if I send it to standard error, well lets just do it. we would have seen it once because the default for standard error is just to push things out. we don't want to wait, we're not trying to get high perforance. you want to know your error messages as soon as possible just in case the process dies very quickly","width":1408},{"text":"so, if we wanted... remember how I said we've got somewhat of a race condition? I've just put in a sleep for a second and that kind of works on this particular system","width":832},{"text":"if we wanted to actually wait for our child ","width":384},{"text":"then I can call waitpid(). so how's waitpid()? let's check the old man page. waitpid","width":1280},{"text":"so, you see we pass in the pid we got from fork. we can get some status information and there's some flags as well that we don't need today","width":832},{"text":"so what we'll change now in our output? ok, what's our little error here? ","width":704},{"text":"oh I didn't declare a little variable. there we go","width":832},{"text":"OK so this time the parent of the child is still the, huh. OK.","width":1408},{"text":"why would that be? so the parent is waiting for the - oh. Yeah we called waitpid() on two, we should only be doing that inside the parent, so let's do that for the parent. so if I'm the parent then ","width":1408},{"text":"we'll wait for our child to sleep","width":384},{"text":"OK yeah now thats sorted, that makes sense. what've we got there? the orignal one is 198 and it's parent is 43 which is probably this little shell program here that's running and the child is 199 and it's child is 198 so we should have two numbers right which are the same","width":1408},{"text":"this is the child saying 'oh look here's my parent 198 and this is our original program 198 saying my parent is 43'","width":576},{"text":"so, you can actually discover all the processes running on your system. this one doesn't have that many and I don't know if you've got pstree involved","width":768},{"text":"you can use ps and pstree to kinda get a hierarchal view of all the processes that a process has. there's different options to say OK, I want to know about my process or everybodys processes but don't worry that's not on the test","width":1216}]