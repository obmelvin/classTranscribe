[{"text":"okay alright so, we've got a typedef that say \"typedef void (*sighandler_t)(int)\"","width":448},{"text":"and then this sighandler underscore t. let's talk about this for a moment. as to how to parse this","width":640},{"text":"alright, so we know that typedef just really means \"hey! I'm an alias\" I'm just defining a new type and in this case, this is a function pointer","width":960},{"text":"so, we can [something] this by unpacking it from the inside out. so, we can have a function that takes an integer","width":448},{"text":"and returns nothing","width":256},{"text":"and, our type goes in the middle (between the parenthesis)","width":384},{"text":"so have a pointer to a function. in other words, just, where do we want to send the CPU to actually execute some code? here's our little function that's gonna happen","width":576},{"text":"and then I can install this handler for a particular signal","width":256},{"text":"so should a certain signal happen, run this handler","width":192},{"text":"alright, so, let's do that","width":192},{"text":"I'm gonna have a signal handle then. and I can call it noway. I can call it anything I want, really.","width":832},{"text":"remember it takes a void. call it agentsmith alright, you'll see why in a moment. and remember it takes an int","width":832},{"text":"so, at this point, we'll write something out. like, \"you can't stop me!\"","width":640},{"text":"okay, how many letters is that? who knows? about 30.","width":256},{"text":"and, we want this to run anytime someone tries to stop this program","width":384},{"text":"so, let's use that signal() thing","width":128},{"text":"so we'll say signal when I get a SIGINT, run agentsmith","width":576},{"text":"and, then i'll have a little loop that does a. keeps itself busy. while(1) loop forever","width":576},{"text":"so, while true, keep going","width":128},{"text":"alright so, let's run this little program here","width":192},{"text":"okay, off it goes, and let's try and press Ctrl-C","width":896},{"text":"oh no! alright, you can't stop agent smith here. anytime you press Ctrl-C, that signal is delivered and fortunately, you can press Ctrl-\\ and that should","width":896},{"text":"okay, there we go, alright. I can at least Ctrl-Z it so I can actually stop the program. so something else to show gives me the ability to pause the program.","width":832},{"text":"and if I wish, I could actually put that into the background. does it support it? okay, yeah, it does and now its in the background","width":320},{"text":"and now it's just running and using up my CPU","width":384},{"text":"if I do \"ps\", there it is. it's running. it's used up 32 seconds, now its used up 34 seconds of CPU, I'd better kill it.","width":576},{"text":"okay, kill minus 9 106","width":192},{"text":"it's gone! remember, SIGINT you cannot stop. so you could try to. sorry, SIGKILL or SIGTERM you cannot stop SIGTERM","width":704},{"text":"alright let's go back","width":128},{"text":"right, so let's first see what it's going to do with child processes. here's the whole thing. let's change our message to say \"child finished\"","width":768},{"text":"and this time, we will make our message a string here so char mesg","width":512},{"text":"I can get a signal when one of my children dies","width":448},{"text":"so strlen(mesg)","width":320},{"text":"okay, right, so, write out the number of bytes that's in that message","width":320},{"text":"so now, rather than doing SIGINT, guess what, there's something called SIGCHILD","width":640},{"text":"and let's make this a little larger","width":320},{"text":"and this time rather than looping forever, we'll do our fork() and now when the child is finished running ls, why did it, oh, aha!","width":1728},{"text":"that's not gonna be very useful, okay.","width":128},{"text":"we'll get rid of the sleep() there as well","width":384},{"text":"so, this time, the child runs ls hopefully, oh, no.","width":512},{"text":"SIG, oh, I can't spell","width":192},{"text":"yes, for some reason, CHLD is spelled without the I","width":320},{"text":"I guess bytes were expensive in those days? okay, alright so, hooray! here's what we've got","width":512},{"text":"the child ran and then the parent was notified asynchronously that the child finished","width":640},{"text":"so if you wanted to do some stuff in the background and you're worried about zombies, this is the perfect place to put that waitpid","width":512},{"text":"to say \"hey! I need to clean up my children\"","width":256},{"text":"so that's in fact a very common convention with these kinds of programs","width":256},{"text":"is, if you don't want to just fork() and then wait() immediately, just write yourself one of these signal handlers and then we can put our waitpid in here","width":640},{"text":"so, we'll need to know the child id, we have a status variable, and a zero here, okay","width":512},{"text":"the last thing I need to do here is that child itself [something] out of scope here. so instead, let me declare as a global variable","width":832},{"text":"now, global variables in large programs considered [something] programming practices. however, you will often see them in small, single-file system programming examples","width":960},{"text":"because it's an easy way to communicate with signal handlers","width":256},{"text":"alright so now, okay, well, you can imagine if I was actually able to type, you can see that we're being good citizens and we're cleaning up our children using a signal handler","width":896}]