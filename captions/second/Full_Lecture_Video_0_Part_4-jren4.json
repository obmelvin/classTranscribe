[{"text":"let's do our last little thing here. what is typedef?","width":553},{"text":"it's just an alias","width":213},{"text":"we've got some basic types in C, but you can use the keyword typedef to say 'hey I need something else'","width":625},{"text":"I might have an unsigned int","width":428},{"text":"OK, that's a lot to type. I'm just going to call that my u int or I'm going to use an unsigned int to represent process identifiers for example. So don't be scared when you see typedef, it's just being able to alias a particular type so that you can have a short name for it","width":1430},{"text":"questions? yes!","width":426},{"text":"because writing struct x is painful and people don't want to have to write the keyword struct everytime","width":1247},{"text":"let's say I have a struct called poem","width":989},{"text":"now I'd have to say 'right suppose i wanted some memory'","width":203},{"text":"I want a pointer to a poem, so struct of poem pointer malloc sizeof struct poem","width":769},{"text":"it's kind of annoying to keep writing struct everywhere, yes? so instead you'd say typedef and that can be my poem struct","width":1168},{"text":"And then you might go further and say I want a poem pointer, so poem_s star poemptr","width":824},{"text":"then you might write this code and then you might write this code and that would be wrong","width":722},{"text":"whoops, look, i just tried to get the size of my pointer. that's going to be four bytes or eight bytes","width":322},{"text":"I didn't want that, I wanted the sizeof my original structure. be careful when you start playing with typedefs","width":932},{"text":"you'll see typedefs commonly used with structs and for things like unsigned ints","width":1041},{"text":"let's not compile this code for now","width":674},{"text":"instead let's print some things out here. how can I print strings out and single characters? well you've seen printf, fantastic. guess what? there's also","width":773},{"text":"putchar sixty five and that's going to print","width":565},{"text":"a single 'a'","width":203},{"text":"so if you wanted to print out a single character, there are these C calls like putchar","width":607},{"text":"if you want to print out a line, there's put s","width":417},{"text":"Hello World","width":315},{"text":"'It prints a new line too'","width":407},{"text":"so that's useful if you know that all you need to do is print out a C string. it will print out a c string followed by a new line","width":658},{"text":"all of these calls underneath end up calling, what? ","width":423},{"text":"yes, they call write","width":254},{"text":"<gibberish> some point your C library says I've had enough holding these bytes, I want to get rid of them, I want to flush them, I want to send them out and when it wants to do that it calls write to the OS","width":766},{"text":"it turns out actually you don't need to print everything to stdout. your processes by default have two output streams. one called standard out, one called standard error. let's prove that","width":1202},{"text":"let's use fprintf. I'm going to say something like 'this is using printf' and we'll try to run that and it doesn't work","width":829},{"text":"we get an error because we haven't given enough arguments to fprintf and in fact the. let's look it up","width":1177},{"text":"fprintf, yeah we need the file stream first. we can say standard error","width":830},{"text":"here's the thinking, here's why standard out and standard error exist and they're not quite the same","width":293},{"text":"quite often when we want to use these tools we want to process the output of one tool and send it immediately into the input of another tool","width":505},{"text":"but what about errors? well we'd like to see them still in the terminal, we'd like to send them to a different file","width":375},{"text":"you're compiler for example, might send - ahh","width":339},{"text":"what have we done wrong here? standard error undeclared? ah","width":910},{"text":"OK, great, that really did print. This is using fprintf. We can send things to these two different output streams and you too can make your own output strings by using fopen","width":1145},{"text":"And also they have different bufferings","width":716},{"text":"What've we got here? I've shown you things like puts and putchar","width":730},{"text":"how do I print - use fprintf, for example, I can send it to standard eror, blah blah blah","width":672},{"text":"is standard error buffered like standard out? no! standard error immediately calls write, it doesn't try to do any buffering","width":986},{"text":"standard out is a little bit diferent. standard out tries to have better performance, so rather than writing every single byte, let's collect a few up and once we assembled enough bytes then we'll call write and make it appear","width":964},{"text":"standard out by default when you're just looking at things in terminal buffers until you see a new line","width":672},{"text":"so if we see a new line, let's flush that buffer!","width":340},{"text":"in other words, call write on the whole buffer and out it goes","width":248}]